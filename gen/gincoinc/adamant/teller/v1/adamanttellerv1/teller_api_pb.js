// source: gincoinc/adamant/teller/v1/adamanttellerv1/teller_api.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global = (function() { return this || window || global || self || Function('return this')(); }).call(null);

var gincoinc_adamant_global_v1_adamantglobalv1_enum_pb = require('../../../../../gincoinc/adamant/global/v1/adamantglobalv1/enum_pb.js');
goog.object.extend(proto, gincoinc_adamant_global_v1_adamantglobalv1_enum_pb);
var gincoinc_adamant_global_v1_adamantglobalv1_global_api_pb = require('../../../../../gincoinc/adamant/global/v1/adamantglobalv1/global_api_pb.js');
goog.object.extend(proto, gincoinc_adamant_global_v1_adamantglobalv1_global_api_pb);
var gincoinc_adamant_global_v1_adamantglobalv1_model_pb = require('../../../../../gincoinc/adamant/global/v1/adamantglobalv1/model_pb.js');
goog.object.extend(proto, gincoinc_adamant_global_v1_adamantglobalv1_model_pb);
var gincoinc_global_v1_gincoincglobalv1_enum_pb = require('../../../../../gincoinc/global/v1/gincoincglobalv1/enum_pb.js');
goog.object.extend(proto, gincoinc_global_v1_gincoincglobalv1_enum_pb);
var google_protobuf_empty_pb = require('google-protobuf/google/protobuf/empty_pb.js');
goog.object.extend(proto, google_protobuf_empty_pb);
var validate_validate_pb = require('../../../../../validate/validate_pb.js');
goog.object.extend(proto, validate_validate_pb);
goog.exportSymbol('proto.adamant.teller.v1.CreateWalletRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.InitializeWalletRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.InitializeXRPWalletRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ProgmatCoinBurnRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ProgmatCoinConfiscateRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ProgmatCoinInitializeRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ProgmatCoinMintRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ProgmatCoinPauseRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ProgmatCoinUnpauseRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.ResendTransactionRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.SendTransactionRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.SignMessageRequest', null, global);
goog.exportSymbol('proto.adamant.teller.v1.SignMessageResponse', null, global);
goog.exportSymbol('proto.adamant.teller.v1.SignTransactionRequest', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.CreateWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.CreateWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.CreateWalletRequest.displayName = 'proto.adamant.teller.v1.CreateWalletRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.InitializeXRPWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.InitializeXRPWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.InitializeXRPWalletRequest.displayName = 'proto.adamant.teller.v1.InitializeXRPWalletRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.InitializeWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.InitializeWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.InitializeWalletRequest.displayName = 'proto.adamant.teller.v1.InitializeWalletRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.SignTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.SignTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.SignTransactionRequest.displayName = 'proto.adamant.teller.v1.SignTransactionRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.SignMessageRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.SignMessageRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.SignMessageRequest.displayName = 'proto.adamant.teller.v1.SignMessageRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.SignMessageResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.SignMessageResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.SignMessageResponse.displayName = 'proto.adamant.teller.v1.SignMessageResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.SendTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.SendTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.SendTransactionRequest.displayName = 'proto.adamant.teller.v1.SendTransactionRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ResendTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.ResendTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ResendTransactionRequest.displayName = 'proto.adamant.teller.v1.ResendTransactionRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.ProgmatCoinInitializeRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ProgmatCoinInitializeRequest.displayName = 'proto.adamant.teller.v1.ProgmatCoinInitializeRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.displayName = 'proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.displayName = 'proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.ProgmatCoinMintRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ProgmatCoinMintRequest.displayName = 'proto.adamant.teller.v1.ProgmatCoinMintRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.ProgmatCoinBurnRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ProgmatCoinBurnRequest.displayName = 'proto.adamant.teller.v1.ProgmatCoinBurnRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.repeatedFields_, null);
};
goog.inherits(proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.displayName = 'proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.repeatedFields_, null);
};
goog.inherits(proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.displayName = 'proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.repeatedFields_, null);
};
goog.inherits(proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.displayName = 'proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.repeatedFields_, null);
};
goog.inherits(proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.displayName = 'proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.ProgmatCoinConfiscateRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.displayName = 'proto.adamant.teller.v1.ProgmatCoinConfiscateRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.ProgmatCoinPauseRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ProgmatCoinPauseRequest.displayName = 'proto.adamant.teller.v1.ProgmatCoinPauseRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.ProgmatCoinUnpauseRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.displayName = 'proto.adamant.teller.v1.ProgmatCoinUnpauseRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest.displayName = 'proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.repeatedFields_, null);
};
goog.inherits(proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.displayName = 'proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest.displayName = 'proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.repeatedFields_, null);
};
goog.inherits(proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.displayName = 'proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.CreateWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.CreateWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.CreateWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletName: jspb.Message.getFieldWithDefault(msg, 1, ""),
    coin: jspb.Message.getFieldWithDefault(msg, 2, 0),
    network: jspb.Message.getFieldWithDefault(msg, 7, 0),
    walletType: jspb.Message.getFieldWithDefault(msg, 3, 0),
    addressType: jspb.Message.getFieldWithDefault(msg, 4, 0),
    destinationWalletId: jspb.Message.getFieldWithDefault(msg, 5, ""),
    inheritWalletId: jspb.Message.getFieldWithDefault(msg, 6, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.CreateWalletRequest}
 */
proto.adamant.teller.v1.CreateWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.CreateWalletRequest;
  return proto.adamant.teller.v1.CreateWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.CreateWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.CreateWalletRequest}
 */
proto.adamant.teller.v1.CreateWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletName(value);
      break;
    case 2:
      var value = /** @type {!proto.gincoinc.global.v1.Coin} */ (reader.readEnum());
      msg.setCoin(value);
      break;
    case 7:
      var value = /** @type {!proto.gincoinc.global.v1.Network} */ (reader.readEnum());
      msg.setNetwork(value);
      break;
    case 3:
      var value = /** @type {!proto.adamant.global.v1.WalletType} */ (reader.readEnum());
      msg.setWalletType(value);
      break;
    case 4:
      var value = /** @type {!proto.gincoinc.global.v1.AddressType} */ (reader.readEnum());
      msg.setAddressType(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setDestinationWalletId(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setInheritWalletId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.CreateWalletRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.CreateWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.CreateWalletRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getCoin();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = /** @type {!proto.gincoinc.global.v1.Network} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeEnum(
      7,
      f
    );
  }
  f = message.getWalletType();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
  f = message.getAddressType();
  if (f !== 0.0) {
    writer.writeEnum(
      4,
      f
    );
  }
  f = message.getDestinationWalletId();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getInheritWalletId();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
};


/**
 * optional string wallet_name = 1;
 * @return {string}
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.getWalletName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.CreateWalletRequest} returns this
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.setWalletName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional gincoinc.global.v1.Coin coin = 2;
 * @return {!proto.gincoinc.global.v1.Coin}
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.getCoin = function() {
  return /** @type {!proto.gincoinc.global.v1.Coin} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.gincoinc.global.v1.Coin} value
 * @return {!proto.adamant.teller.v1.CreateWalletRequest} returns this
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.setCoin = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional gincoinc.global.v1.Network network = 7;
 * @return {!proto.gincoinc.global.v1.Network}
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.getNetwork = function() {
  return /** @type {!proto.gincoinc.global.v1.Network} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {!proto.gincoinc.global.v1.Network} value
 * @return {!proto.adamant.teller.v1.CreateWalletRequest} returns this
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.setNetwork = function(value) {
  return jspb.Message.setField(this, 7, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.adamant.teller.v1.CreateWalletRequest} returns this
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.clearNetwork = function() {
  return jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.hasNetwork = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional adamant.global.v1.WalletType wallet_type = 3;
 * @return {!proto.adamant.global.v1.WalletType}
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.getWalletType = function() {
  return /** @type {!proto.adamant.global.v1.WalletType} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {!proto.adamant.global.v1.WalletType} value
 * @return {!proto.adamant.teller.v1.CreateWalletRequest} returns this
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.setWalletType = function(value) {
  return jspb.Message.setProto3EnumField(this, 3, value);
};


/**
 * optional gincoinc.global.v1.AddressType address_type = 4;
 * @return {!proto.gincoinc.global.v1.AddressType}
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.getAddressType = function() {
  return /** @type {!proto.gincoinc.global.v1.AddressType} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {!proto.gincoinc.global.v1.AddressType} value
 * @return {!proto.adamant.teller.v1.CreateWalletRequest} returns this
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.setAddressType = function(value) {
  return jspb.Message.setProto3EnumField(this, 4, value);
};


/**
 * optional string destination_wallet_id = 5;
 * @return {string}
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.getDestinationWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.CreateWalletRequest} returns this
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.setDestinationWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};


/**
 * optional string inherit_wallet_id = 6;
 * @return {string}
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.getInheritWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.CreateWalletRequest} returns this
 */
proto.adamant.teller.v1.CreateWalletRequest.prototype.setInheritWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 6, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.InitializeXRPWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.InitializeXRPWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.InitializeXRPWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.InitializeXRPWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.InitializeXRPWalletRequest}
 */
proto.adamant.teller.v1.InitializeXRPWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.InitializeXRPWalletRequest;
  return proto.adamant.teller.v1.InitializeXRPWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.InitializeXRPWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.InitializeXRPWalletRequest}
 */
proto.adamant.teller.v1.InitializeXRPWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.InitializeXRPWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.InitializeXRPWalletRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.InitializeXRPWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.InitializeXRPWalletRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.InitializeXRPWalletRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.InitializeXRPWalletRequest} returns this
 */
proto.adamant.teller.v1.InitializeXRPWalletRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.InitializeWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.InitializeWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.InitializeWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.InitializeWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.InitializeWalletRequest}
 */
proto.adamant.teller.v1.InitializeWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.InitializeWalletRequest;
  return proto.adamant.teller.v1.InitializeWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.InitializeWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.InitializeWalletRequest}
 */
proto.adamant.teller.v1.InitializeWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.InitializeWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.InitializeWalletRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.InitializeWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.InitializeWalletRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.InitializeWalletRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.InitializeWalletRequest} returns this
 */
proto.adamant.teller.v1.InitializeWalletRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.SignTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.SignTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.SignTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.SignTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    transactionId: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.SignTransactionRequest}
 */
proto.adamant.teller.v1.SignTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.SignTransactionRequest;
  return proto.adamant.teller.v1.SignTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.SignTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.SignTransactionRequest}
 */
proto.adamant.teller.v1.SignTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setTransactionId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.SignTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.SignTransactionRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.SignTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.SignTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getTransactionId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.SignTransactionRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.SignTransactionRequest} returns this
 */
proto.adamant.teller.v1.SignTransactionRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string transaction_id = 2;
 * @return {string}
 */
proto.adamant.teller.v1.SignTransactionRequest.prototype.getTransactionId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.SignTransactionRequest} returns this
 */
proto.adamant.teller.v1.SignTransactionRequest.prototype.setTransactionId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.SignMessageRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.SignMessageRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.SignMessageRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    addressId: jspb.Message.getFieldWithDefault(msg, 2, ""),
    address: jspb.Message.getFieldWithDefault(msg, 4, ""),
    message: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.SignMessageRequest}
 */
proto.adamant.teller.v1.SignMessageRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.SignMessageRequest;
  return proto.adamant.teller.v1.SignMessageRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.SignMessageRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.SignMessageRequest}
 */
proto.adamant.teller.v1.SignMessageRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddressId(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.SignMessageRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.SignMessageRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.SignMessageRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getMessage();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.SignMessageRequest} returns this
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string address_id = 2;
 * @return {string}
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.getAddressId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.SignMessageRequest} returns this
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.setAddressId = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.adamant.teller.v1.SignMessageRequest} returns this
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.clearAddressId = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.hasAddressId = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string address = 4;
 * @return {string}
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.SignMessageRequest} returns this
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.setAddress = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.adamant.teller.v1.SignMessageRequest} returns this
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.clearAddress = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional string message = 3;
 * @return {string}
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.SignMessageRequest} returns this
 */
proto.adamant.teller.v1.SignMessageRequest.prototype.setMessage = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.SignMessageResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.SignMessageResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.SignMessageResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.SignMessageResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    signature: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.SignMessageResponse}
 */
proto.adamant.teller.v1.SignMessageResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.SignMessageResponse;
  return proto.adamant.teller.v1.SignMessageResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.SignMessageResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.SignMessageResponse}
 */
proto.adamant.teller.v1.SignMessageResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.SignMessageResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.SignMessageResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.SignMessageResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.SignMessageResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSignature();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string signature = 1;
 * @return {string}
 */
proto.adamant.teller.v1.SignMessageResponse.prototype.getSignature = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.SignMessageResponse} returns this
 */
proto.adamant.teller.v1.SignMessageResponse.prototype.setSignature = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.SendTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.SendTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.SendTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.SendTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    transactionId: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.SendTransactionRequest}
 */
proto.adamant.teller.v1.SendTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.SendTransactionRequest;
  return proto.adamant.teller.v1.SendTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.SendTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.SendTransactionRequest}
 */
proto.adamant.teller.v1.SendTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setTransactionId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.SendTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.SendTransactionRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.SendTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.SendTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getTransactionId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.SendTransactionRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.SendTransactionRequest} returns this
 */
proto.adamant.teller.v1.SendTransactionRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string transaction_id = 2;
 * @return {string}
 */
proto.adamant.teller.v1.SendTransactionRequest.prototype.getTransactionId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.SendTransactionRequest} returns this
 */
proto.adamant.teller.v1.SendTransactionRequest.prototype.setTransactionId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ResendTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ResendTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ResendTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ResendTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    transactionId: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ResendTransactionRequest}
 */
proto.adamant.teller.v1.ResendTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ResendTransactionRequest;
  return proto.adamant.teller.v1.ResendTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ResendTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ResendTransactionRequest}
 */
proto.adamant.teller.v1.ResendTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setTransactionId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ResendTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ResendTransactionRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ResendTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ResendTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getTransactionId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ResendTransactionRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ResendTransactionRequest} returns this
 */
proto.adamant.teller.v1.ResendTransactionRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string transaction_id = 2;
 * @return {string}
 */
proto.adamant.teller.v1.ResendTransactionRequest.prototype.getTransactionId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ResendTransactionRequest} returns this
 */
proto.adamant.teller.v1.ResendTransactionRequest.prototype.setTransactionId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ProgmatCoinInitializeRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    feeRate: jspb.Message.getFieldWithDefault(msg, 2, 0),
    contractAddress: jspb.Message.getFieldWithDefault(msg, 3, ""),
    tokenName: jspb.Message.getFieldWithDefault(msg, 4, ""),
    tokenSymbol: jspb.Message.getFieldWithDefault(msg, 5, ""),
    tokenCurrency: jspb.Message.getFieldWithDefault(msg, 6, ""),
    tokenDecimals: jspb.Message.getFieldWithDefault(msg, 7, 0),
    newMasterMinter: jspb.Message.getFieldWithDefault(msg, 8, ""),
    newPauser: jspb.Message.getFieldWithDefault(msg, 9, ""),
    newWhiteAndBlackLister: jspb.Message.getFieldWithDefault(msg, 10, ""),
    newConfiscator: jspb.Message.getFieldWithDefault(msg, 11, ""),
    newOwner: jspb.Message.getFieldWithDefault(msg, 12, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ProgmatCoinInitializeRequest;
  return proto.adamant.teller.v1.ProgmatCoinInitializeRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeRate(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractAddress(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setTokenName(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setTokenSymbol(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setTokenCurrency(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setTokenDecimals(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setNewMasterMinter(value);
      break;
    case 9:
      var value = /** @type {string} */ (reader.readString());
      msg.setNewPauser(value);
      break;
    case 10:
      var value = /** @type {string} */ (reader.readString());
      msg.setNewWhiteAndBlackLister(value);
      break;
    case 11:
      var value = /** @type {string} */ (reader.readString());
      msg.setNewConfiscator(value);
      break;
    case 12:
      var value = /** @type {string} */ (reader.readString());
      msg.setNewOwner(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ProgmatCoinInitializeRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getContractAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getTokenName();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getTokenSymbol();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getTokenCurrency();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
  f = message.getTokenDecimals();
  if (f !== 0) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = message.getNewMasterMinter();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
  f = message.getNewPauser();
  if (f.length > 0) {
    writer.writeString(
      9,
      f
    );
  }
  f = message.getNewWhiteAndBlackLister();
  if (f.length > 0) {
    writer.writeString(
      10,
      f
    );
  }
  f = message.getNewConfiscator();
  if (f.length > 0) {
    writer.writeString(
      11,
      f
    );
  }
  f = message.getNewOwner();
  if (f.length > 0) {
    writer.writeString(
      12,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 fee_rate = 2;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.setFeeRate = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string contract_address = 3;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.getContractAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.setContractAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string token_name = 4;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.getTokenName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.setTokenName = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional string token_symbol = 5;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.getTokenSymbol = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.setTokenSymbol = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};


/**
 * optional string token_currency = 6;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.getTokenCurrency = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.setTokenCurrency = function(value) {
  return jspb.Message.setProto3StringField(this, 6, value);
};


/**
 * optional uint32 token_decimals = 7;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.getTokenDecimals = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.setTokenDecimals = function(value) {
  return jspb.Message.setProto3IntField(this, 7, value);
};


/**
 * optional string new_master_minter = 8;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.getNewMasterMinter = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.setNewMasterMinter = function(value) {
  return jspb.Message.setProto3StringField(this, 8, value);
};


/**
 * optional string new_pauser = 9;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.getNewPauser = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 9, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.setNewPauser = function(value) {
  return jspb.Message.setProto3StringField(this, 9, value);
};


/**
 * optional string new_white_and_black_lister = 10;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.getNewWhiteAndBlackLister = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 10, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.setNewWhiteAndBlackLister = function(value) {
  return jspb.Message.setProto3StringField(this, 10, value);
};


/**
 * optional string new_confiscator = 11;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.getNewConfiscator = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 11, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.setNewConfiscator = function(value) {
  return jspb.Message.setProto3StringField(this, 11, value);
};


/**
 * optional string new_owner = 12;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.getNewOwner = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 12, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinInitializeRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinInitializeRequest.prototype.setNewOwner = function(value) {
  return jspb.Message.setProto3StringField(this, 12, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    feeRate: jspb.Message.getFieldWithDefault(msg, 2, 0),
    contractAddress: jspb.Message.getFieldWithDefault(msg, 3, ""),
    address: jspb.Message.getFieldWithDefault(msg, 4, ""),
    minterAllowedAmount: jspb.Message.getFieldWithDefault(msg, 5, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest}
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest;
  return proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest}
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeRate(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractAddress(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setMinterAllowedAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getContractAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getMinterAllowedAmount();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 fee_rate = 2;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.prototype.setFeeRate = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string contract_address = 3;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.prototype.getContractAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.prototype.setContractAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string address = 4;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.prototype.setAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional string minter_allowed_amount = 5;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.prototype.getMinterAllowedAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinConfigureMinterRequest.prototype.setMinterAllowedAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    feeRate: jspb.Message.getFieldWithDefault(msg, 2, 0),
    contractAddress: jspb.Message.getFieldWithDefault(msg, 3, ""),
    mintAddress: jspb.Message.getFieldWithDefault(msg, 4, ""),
    transferAddress: jspb.Message.getFieldWithDefault(msg, 5, ""),
    amount: jspb.Message.getFieldWithDefault(msg, 6, ""),
    throughAddress: jspb.Message.getFieldWithDefault(msg, 7, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest}
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest;
  return proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest}
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeRate(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractAddress(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setMintAddress(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setTransferAddress(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setThroughAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getContractAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getMintAddress();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getTransferAddress();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeString(
      7,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 fee_rate = 2;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.setFeeRate = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string contract_address = 3;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.getContractAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.setContractAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string mint_address = 4;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.getMintAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.setMintAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional string transfer_address = 5;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.getTransferAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.setTransferAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};


/**
 * optional string amount = 6;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 6, value);
};


/**
 * optional string through_address = 7;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.getThroughAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.setThroughAddress = function(value) {
  return jspb.Message.setField(this, 7, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.clearThroughAddress = function() {
  return jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.adamant.teller.v1.ProgmatCoinMintAndTransferRequest.prototype.hasThroughAddress = function() {
  return jspb.Message.getField(this, 7) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ProgmatCoinMintRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ProgmatCoinMintRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    feeRate: jspb.Message.getFieldWithDefault(msg, 2, 0),
    contractAddress: jspb.Message.getFieldWithDefault(msg, 3, ""),
    address: jspb.Message.getFieldWithDefault(msg, 4, ""),
    amount: jspb.Message.getFieldWithDefault(msg, 5, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintRequest}
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ProgmatCoinMintRequest;
  return proto.adamant.teller.v1.ProgmatCoinMintRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ProgmatCoinMintRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintRequest}
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeRate(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractAddress(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ProgmatCoinMintRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ProgmatCoinMintRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getContractAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 fee_rate = 2;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.prototype.setFeeRate = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string contract_address = 3;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.prototype.getContractAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.prototype.setContractAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string address = 4;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.prototype.setAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional string amount = 5;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinMintRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinMintRequest.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ProgmatCoinBurnRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ProgmatCoinBurnRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    feeRate: jspb.Message.getFieldWithDefault(msg, 2, 0),
    contractAddress: jspb.Message.getFieldWithDefault(msg, 3, ""),
    amount: jspb.Message.getFieldWithDefault(msg, 4, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBurnRequest}
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ProgmatCoinBurnRequest;
  return proto.adamant.teller.v1.ProgmatCoinBurnRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ProgmatCoinBurnRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBurnRequest}
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeRate(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractAddress(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ProgmatCoinBurnRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ProgmatCoinBurnRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getContractAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBurnRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 fee_rate = 2;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBurnRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.prototype.setFeeRate = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string contract_address = 3;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.prototype.getContractAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBurnRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.prototype.setContractAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string amount = 4;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBurnRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBurnRequest.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    feeRate: jspb.Message.getFieldWithDefault(msg, 2, 0),
    contractAddress: jspb.Message.getFieldWithDefault(msg, 3, ""),
    utilsAddress: jspb.Message.getFieldWithDefault(msg, 4, ""),
    addressesList: (f = jspb.Message.getRepeatedField(msg, 5)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest;
  return proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeRate(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractAddress(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setUtilsAddress(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.addAddresses(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getContractAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getUtilsAddress();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getAddressesList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      5,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 fee_rate = 2;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.setFeeRate = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string contract_address = 3;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.getContractAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.setContractAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string utils_address = 4;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.getUtilsAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.setUtilsAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * repeated string addresses = 5;
 * @return {!Array<string>}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.getAddressesList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 5));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.setAddressesList = function(value) {
  return jspb.Message.setField(this, 5, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.addAddresses = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 5, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToWhitelistRequest.prototype.clearAddressesList = function() {
  return this.setAddressesList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    feeRate: jspb.Message.getFieldWithDefault(msg, 2, 0),
    contractAddress: jspb.Message.getFieldWithDefault(msg, 3, ""),
    utilsAddress: jspb.Message.getFieldWithDefault(msg, 4, ""),
    addressesList: (f = jspb.Message.getRepeatedField(msg, 5)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest;
  return proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeRate(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractAddress(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setUtilsAddress(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.addAddresses(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getContractAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getUtilsAddress();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getAddressesList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      5,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 fee_rate = 2;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.setFeeRate = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string contract_address = 3;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.getContractAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.setContractAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string utils_address = 4;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.getUtilsAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.setUtilsAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * repeated string addresses = 5;
 * @return {!Array<string>}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.getAddressesList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 5));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.setAddressesList = function(value) {
  return jspb.Message.setField(this, 5, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.addAddresses = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 5, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromWhitelistRequest.prototype.clearAddressesList = function() {
  return this.setAddressesList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    feeRate: jspb.Message.getFieldWithDefault(msg, 2, 0),
    contractAddress: jspb.Message.getFieldWithDefault(msg, 3, ""),
    utilsAddress: jspb.Message.getFieldWithDefault(msg, 4, ""),
    addressesList: (f = jspb.Message.getRepeatedField(msg, 5)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest;
  return proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeRate(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractAddress(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setUtilsAddress(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.addAddresses(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getContractAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getUtilsAddress();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getAddressesList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      5,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 fee_rate = 2;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.setFeeRate = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string contract_address = 3;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.getContractAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.setContractAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string utils_address = 4;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.getUtilsAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.setUtilsAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * repeated string addresses = 5;
 * @return {!Array<string>}
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.getAddressesList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 5));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.setAddressesList = function(value) {
  return jspb.Message.setField(this, 5, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.addAddresses = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 5, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkAddToBlacklistRequest.prototype.clearAddressesList = function() {
  return this.setAddressesList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    feeRate: jspb.Message.getFieldWithDefault(msg, 2, 0),
    contractAddress: jspb.Message.getFieldWithDefault(msg, 3, ""),
    utilsAddress: jspb.Message.getFieldWithDefault(msg, 4, ""),
    addressesList: (f = jspb.Message.getRepeatedField(msg, 5)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest;
  return proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeRate(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractAddress(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setUtilsAddress(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.addAddresses(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getContractAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getUtilsAddress();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getAddressesList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      5,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 fee_rate = 2;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.setFeeRate = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string contract_address = 3;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.getContractAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.setContractAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string utils_address = 4;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.getUtilsAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.setUtilsAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * repeated string addresses = 5;
 * @return {!Array<string>}
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.getAddressesList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 5));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.setAddressesList = function(value) {
  return jspb.Message.setField(this, 5, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.addAddresses = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 5, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinBulkRemoveFromBlacklistRequest.prototype.clearAddressesList = function() {
  return this.setAddressesList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ProgmatCoinConfiscateRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    feeRate: jspb.Message.getFieldWithDefault(msg, 2, 0),
    contractAddress: jspb.Message.getFieldWithDefault(msg, 3, ""),
    blackListedAccount: jspb.Message.getFieldWithDefault(msg, 4, ""),
    toAccount: jspb.Message.getFieldWithDefault(msg, 5, ""),
    amount: jspb.Message.getFieldWithDefault(msg, 6, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfiscateRequest}
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ProgmatCoinConfiscateRequest;
  return proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ProgmatCoinConfiscateRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfiscateRequest}
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeRate(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractAddress(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setBlackListedAccount(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setToAccount(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ProgmatCoinConfiscateRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getContractAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getBlackListedAccount();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getToAccount();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfiscateRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 fee_rate = 2;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfiscateRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.setFeeRate = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string contract_address = 3;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.getContractAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfiscateRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.setContractAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string black_listed_account = 4;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.getBlackListedAccount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfiscateRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.setBlackListedAccount = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional string to_account = 5;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.getToAccount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfiscateRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.setToAccount = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};


/**
 * optional string amount = 6;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinConfiscateRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinConfiscateRequest.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 6, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ProgmatCoinPauseRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ProgmatCoinPauseRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    feeRate: jspb.Message.getFieldWithDefault(msg, 2, 0),
    contractAddress: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ProgmatCoinPauseRequest}
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ProgmatCoinPauseRequest;
  return proto.adamant.teller.v1.ProgmatCoinPauseRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ProgmatCoinPauseRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ProgmatCoinPauseRequest}
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeRate(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ProgmatCoinPauseRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ProgmatCoinPauseRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getContractAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinPauseRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 fee_rate = 2;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinPauseRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest.prototype.setFeeRate = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string contract_address = 3;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest.prototype.getContractAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinPauseRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinPauseRequest.prototype.setContractAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ProgmatCoinUnpauseRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    feeRate: jspb.Message.getFieldWithDefault(msg, 2, 0),
    contractAddress: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ProgmatCoinUnpauseRequest}
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ProgmatCoinUnpauseRequest;
  return proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ProgmatCoinUnpauseRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ProgmatCoinUnpauseRequest}
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWalletId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeRate(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ProgmatCoinUnpauseRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getContractAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional string wallet_id = 1;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.prototype.getWalletId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinUnpauseRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.prototype.setWalletId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 fee_rate = 2;
 * @return {number}
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinUnpauseRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.prototype.setFeeRate = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string contract_address = 3;
 * @return {string}
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.prototype.getContractAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.adamant.teller.v1.ProgmatCoinUnpauseRequest} returns this
 */
proto.adamant.teller.v1.ProgmatCoinUnpauseRequest.prototype.setContractAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest}
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest;
  return proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest}
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    callerAddressesList: jspb.Message.toObjectList(msg.getCallerAddressesList(),
    gincoinc_adamant_global_v1_adamantglobalv1_model_pb.CallerAddress.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse}
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse;
  return proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse}
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new gincoinc_adamant_global_v1_adamantglobalv1_model_pb.CallerAddress;
      reader.readMessage(value,gincoinc_adamant_global_v1_adamantglobalv1_model_pb.CallerAddress.deserializeBinaryFromReader);
      msg.addCallerAddresses(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCallerAddressesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      gincoinc_adamant_global_v1_adamantglobalv1_model_pb.CallerAddress.serializeBinaryToWriter
    );
  }
};


/**
 * repeated adamant.global.v1.CallerAddress caller_addresses = 1;
 * @return {!Array<!proto.adamant.global.v1.CallerAddress>}
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.prototype.getCallerAddressesList = function() {
  return /** @type{!Array<!proto.adamant.global.v1.CallerAddress>} */ (
    jspb.Message.getRepeatedWrapperField(this, gincoinc_adamant_global_v1_adamantglobalv1_model_pb.CallerAddress, 1));
};


/**
 * @param {!Array<!proto.adamant.global.v1.CallerAddress>} value
 * @return {!proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse} returns this
*/
proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.prototype.setCallerAddressesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.adamant.global.v1.CallerAddress=} opt_value
 * @param {number=} opt_index
 * @return {!proto.adamant.global.v1.CallerAddress}
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.prototype.addCallerAddresses = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.adamant.global.v1.CallerAddress, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse} returns this
 */
proto.adamant.teller.v1.ListColdFeeDepositAddressesResponse.prototype.clearCallerAddressesList = function() {
  return this.setCallerAddressesList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest}
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest;
  return proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest}
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    feeDepositAddressesList: jspb.Message.toObjectList(msg.getFeeDepositAddressesList(),
    gincoinc_adamant_global_v1_adamantglobalv1_model_pb.FeeDepositAddress.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse}
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse;
  return proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse}
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new gincoinc_adamant_global_v1_adamantglobalv1_model_pb.FeeDepositAddress;
      reader.readMessage(value,gincoinc_adamant_global_v1_adamantglobalv1_model_pb.FeeDepositAddress.deserializeBinaryFromReader);
      msg.addFeeDepositAddresses(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getFeeDepositAddressesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      gincoinc_adamant_global_v1_adamantglobalv1_model_pb.FeeDepositAddress.serializeBinaryToWriter
    );
  }
};


/**
 * repeated adamant.global.v1.FeeDepositAddress fee_deposit_addresses = 1;
 * @return {!Array<!proto.adamant.global.v1.FeeDepositAddress>}
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.prototype.getFeeDepositAddressesList = function() {
  return /** @type{!Array<!proto.adamant.global.v1.FeeDepositAddress>} */ (
    jspb.Message.getRepeatedWrapperField(this, gincoinc_adamant_global_v1_adamantglobalv1_model_pb.FeeDepositAddress, 1));
};


/**
 * @param {!Array<!proto.adamant.global.v1.FeeDepositAddress>} value
 * @return {!proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse} returns this
*/
proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.prototype.setFeeDepositAddressesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.adamant.global.v1.FeeDepositAddress=} opt_value
 * @param {number=} opt_index
 * @return {!proto.adamant.global.v1.FeeDepositAddress}
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.prototype.addFeeDepositAddresses = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.adamant.global.v1.FeeDepositAddress, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse} returns this
 */
proto.adamant.teller.v1.ListHotFeeDepositAddressesResponse.prototype.clearFeeDepositAddressesList = function() {
  return this.setFeeDepositAddressesList([]);
};


goog.object.extend(exports, proto.adamant.teller.v1);
